Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON r body END
Rule 2     r -> vars
Rule 3     r -> empty
Rule 4     vars -> VAR o
Rule 5     o -> s p
Rule 6     s -> ID
Rule 7     p -> COMA o
Rule 8     p -> COLON type SEMICOLON q
Rule 9     q -> empty
Rule 10    q -> o
Rule 11    body -> LEFTBRACE m RIGHTBRACE
Rule 12    m -> statement m
Rule 13    m -> empty
Rule 14    statement -> assign
Rule 15    statement -> condition
Rule 16    statement -> cycle
Rule 17    statement -> print
Rule 18    assign -> id_assign equal_assign expression SEMICOLON
Rule 19    id_assign -> ID
Rule 20    equal_assign -> EQUAL
Rule 21    cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON
Rule 22    do_cycle -> DO
Rule 23    l_par_cycle -> LEFTPARENTHESIS
Rule 24    r_par_cycle -> RIGHTPARENTHESIS
Rule 25    condition -> IF left_par_condition expression right_par_condition body ef SEMICOLON
Rule 26    left_par_condition -> LEFTPARENTHESIS
Rule 27    right_par_condition -> RIGHTPARENTHESIS
Rule 28    ef -> empty
Rule 29    ef -> l
Rule 30    ef -> elif_ef left_par_ef expression right_par_ef body l
Rule 31    elif_ef -> ELSEIF
Rule 32    left_par_ef -> LEFTPARENTHESIS
Rule 33    right_par_ef -> RIGHTPARENTHESIS
Rule 34    l -> else_condition body
Rule 35    else_condition -> ELSE
Rule 36    expression -> exp j
Rule 37    j -> empty
Rule 38    j -> k exp
Rule 39    k -> GREATERTHAN
Rule 40    k -> LESSTHAN
Rule 41    k -> NOT
Rule 42    print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print
Rule 43    cout_print -> COUT
Rule 44    g -> h i
Rule 45    h -> expression_print
Rule 46    h -> CTE_STRING
Rule 47    expression_print -> expression
Rule 48    i -> empty
Rule 49    i -> COMA g
Rule 50    semicolon_print -> SEMICOLON
Rule 51    exp -> term e
Rule 52    e -> empty
Rule 53    e -> f exp
Rule 54    f -> ADD
Rule 55    f -> MINUS
Rule 56    term -> factor c
Rule 57    c -> empty
Rule 58    c -> d term
Rule 59    d -> MULTIPLY
Rule 60    d -> DIVIDE
Rule 61    factor -> left_par_factor expression right_par_factor
Rule 62    factor -> a b
Rule 63    left_par_factor -> LEFTPARENTHESIS
Rule 64    right_par_factor -> RIGHTPARENTHESIS
Rule 65    a -> empty
Rule 66    a -> ADD
Rule 67    a -> MINUS
Rule 68    b -> ID
Rule 69    b -> cte
Rule 70    type -> INT
Rule 71    type -> FLOAT
Rule 72    cte -> CTE_INT
Rule 73    cte -> CTE_FLOAT
Rule 74    empty -> <empty>

Terminals, with rules where they appear

ADD                  : 54 66
COLON                : 8
COMA                 : 7 49
COUT                 : 43
CTE_FLOAT            : 73
CTE_INT              : 72
CTE_STRING           : 46
DIVIDE               : 60
DO                   : 22
ELSE                 : 35
ELSEIF               : 31
END                  : 1
EQUAL                : 20
FLOAT                : 71
GREATERTHAN          : 39
ID                   : 1 6 19 68
IF                   : 25
INT                  : 70
LEFTBRACE            : 11
LEFTPARENTHESIS      : 23 26 32 42 63
LESSTHAN             : 40
MINUS                : 55 67
MULTIPLY             : 59
NOT                  : 41
PROGRAM              : 1
RIGHTBRACE           : 11
RIGHTPARENTHESIS     : 24 27 33 42 64
SEMICOLON            : 1 8 18 21 25 50
VAR                  : 4
WHILE                : 21
error                : 

Nonterminals, with rules where they appear

a                    : 62
assign               : 14
b                    : 62
body                 : 1 21 25 30 34
c                    : 56
condition            : 15
cout_print           : 42
cte                  : 69
cycle                : 16
d                    : 58
do_cycle             : 21
e                    : 51
ef                   : 25
elif_ef              : 30
else_condition       : 34
empty                : 3 9 13 28 37 48 52 57 65
equal_assign         : 18
exp                  : 36 38 53
expression           : 18 21 25 30 47 61
expression_print     : 45
f                    : 53
factor               : 56
g                    : 42 49
h                    : 44
i                    : 44
id_assign            : 18
j                    : 36
k                    : 38
l                    : 29 30
l_par_cycle          : 21
left_par_condition   : 25
left_par_ef          : 30
left_par_factor      : 61
m                    : 11 12
o                    : 4 7 10
p                    : 5
print                : 17
program              : 0
q                    : 8
r                    : 1
r_par_cycle          : 21
right_par_condition  : 25
right_par_ef         : 30
right_par_factor     : 61
s                    : 5
semicolon_print      : 42
statement            : 12
term                 : 51 58
type                 : 8
vars                 : 2

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON r body END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON r body END

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON r body END

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . r body END
    (2) r -> . vars
    (3) r -> . empty
    (4) vars -> . VAR o
    (74) empty -> .

    VAR             shift and go to state 8
    LEFTBRACE       reduce using rule 74 (empty -> .)

    r                              shift and go to state 5
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID SEMICOLON r . body END
    (11) body -> . LEFTBRACE m RIGHTBRACE

    LEFTBRACE       shift and go to state 10

    body                           shift and go to state 9

state 6

    (2) r -> vars .

    LEFTBRACE       reduce using rule 2 (r -> vars .)


state 7

    (3) r -> empty .

    LEFTBRACE       reduce using rule 3 (r -> empty .)


state 8

    (4) vars -> VAR . o
    (5) o -> . s p
    (6) s -> . ID

    ID              shift and go to state 13

    o                              shift and go to state 11
    s                              shift and go to state 12

state 9

    (1) program -> PROGRAM ID SEMICOLON r body . END

    END             shift and go to state 14


state 10

    (11) body -> LEFTBRACE . m RIGHTBRACE
    (12) m -> . statement m
    (13) m -> . empty
    (14) statement -> . assign
    (15) statement -> . condition
    (16) statement -> . cycle
    (17) statement -> . print
    (74) empty -> .
    (18) assign -> . id_assign equal_assign expression SEMICOLON
    (25) condition -> . IF left_par_condition expression right_par_condition body ef SEMICOLON
    (21) cycle -> . do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON
    (42) print -> . cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print
    (19) id_assign -> . ID
    (22) do_cycle -> . DO
    (43) cout_print -> . COUT

    RIGHTBRACE      reduce using rule 74 (empty -> .)
    IF              shift and go to state 23
    ID              shift and go to state 26
    DO              shift and go to state 27
    COUT            shift and go to state 28

    m                              shift and go to state 15
    statement                      shift and go to state 16
    empty                          shift and go to state 17
    assign                         shift and go to state 18
    condition                      shift and go to state 19
    cycle                          shift and go to state 20
    print                          shift and go to state 21
    id_assign                      shift and go to state 22
    do_cycle                       shift and go to state 24
    cout_print                     shift and go to state 25

state 11

    (4) vars -> VAR o .

    LEFTBRACE       reduce using rule 4 (vars -> VAR o .)


state 12

    (5) o -> s . p
    (7) p -> . COMA o
    (8) p -> . COLON type SEMICOLON q

    COMA            shift and go to state 30
    COLON           shift and go to state 31

    p                              shift and go to state 29

state 13

    (6) s -> ID .

    COMA            reduce using rule 6 (s -> ID .)
    COLON           reduce using rule 6 (s -> ID .)


state 14

    (1) program -> PROGRAM ID SEMICOLON r body END .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON r body END .)


state 15

    (11) body -> LEFTBRACE m . RIGHTBRACE

    RIGHTBRACE      shift and go to state 32


state 16

    (12) m -> statement . m
    (12) m -> . statement m
    (13) m -> . empty
    (14) statement -> . assign
    (15) statement -> . condition
    (16) statement -> . cycle
    (17) statement -> . print
    (74) empty -> .
    (18) assign -> . id_assign equal_assign expression SEMICOLON
    (25) condition -> . IF left_par_condition expression right_par_condition body ef SEMICOLON
    (21) cycle -> . do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON
    (42) print -> . cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print
    (19) id_assign -> . ID
    (22) do_cycle -> . DO
    (43) cout_print -> . COUT

    RIGHTBRACE      reduce using rule 74 (empty -> .)
    IF              shift and go to state 23
    ID              shift and go to state 26
    DO              shift and go to state 27
    COUT            shift and go to state 28

    statement                      shift and go to state 16
    m                              shift and go to state 33
    empty                          shift and go to state 17
    assign                         shift and go to state 18
    condition                      shift and go to state 19
    cycle                          shift and go to state 20
    print                          shift and go to state 21
    id_assign                      shift and go to state 22
    do_cycle                       shift and go to state 24
    cout_print                     shift and go to state 25

state 17

    (13) m -> empty .

    RIGHTBRACE      reduce using rule 13 (m -> empty .)


state 18

    (14) statement -> assign .

    IF              reduce using rule 14 (statement -> assign .)
    ID              reduce using rule 14 (statement -> assign .)
    DO              reduce using rule 14 (statement -> assign .)
    COUT            reduce using rule 14 (statement -> assign .)
    RIGHTBRACE      reduce using rule 14 (statement -> assign .)


state 19

    (15) statement -> condition .

    IF              reduce using rule 15 (statement -> condition .)
    ID              reduce using rule 15 (statement -> condition .)
    DO              reduce using rule 15 (statement -> condition .)
    COUT            reduce using rule 15 (statement -> condition .)
    RIGHTBRACE      reduce using rule 15 (statement -> condition .)


state 20

    (16) statement -> cycle .

    IF              reduce using rule 16 (statement -> cycle .)
    ID              reduce using rule 16 (statement -> cycle .)
    DO              reduce using rule 16 (statement -> cycle .)
    COUT            reduce using rule 16 (statement -> cycle .)
    RIGHTBRACE      reduce using rule 16 (statement -> cycle .)


state 21

    (17) statement -> print .

    IF              reduce using rule 17 (statement -> print .)
    ID              reduce using rule 17 (statement -> print .)
    DO              reduce using rule 17 (statement -> print .)
    COUT            reduce using rule 17 (statement -> print .)
    RIGHTBRACE      reduce using rule 17 (statement -> print .)


state 22

    (18) assign -> id_assign . equal_assign expression SEMICOLON
    (20) equal_assign -> . EQUAL

    EQUAL           shift and go to state 35

    equal_assign                   shift and go to state 34

state 23

    (25) condition -> IF . left_par_condition expression right_par_condition body ef SEMICOLON
    (26) left_par_condition -> . LEFTPARENTHESIS

    LEFTPARENTHESIS shift and go to state 37

    left_par_condition             shift and go to state 36

state 24

    (21) cycle -> do_cycle . body WHILE l_par_cycle expression r_par_cycle SEMICOLON
    (11) body -> . LEFTBRACE m RIGHTBRACE

    LEFTBRACE       shift and go to state 10

    body                           shift and go to state 38

state 25

    (42) print -> cout_print . LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print

    LEFTPARENTHESIS shift and go to state 39


state 26

    (19) id_assign -> ID .

    EQUAL           reduce using rule 19 (id_assign -> ID .)


state 27

    (22) do_cycle -> DO .

    LEFTBRACE       reduce using rule 22 (do_cycle -> DO .)


state 28

    (43) cout_print -> COUT .

    LEFTPARENTHESIS reduce using rule 43 (cout_print -> COUT .)


state 29

    (5) o -> s p .

    LEFTBRACE       reduce using rule 5 (o -> s p .)


state 30

    (7) p -> COMA . o
    (5) o -> . s p
    (6) s -> . ID

    ID              shift and go to state 13

    o                              shift and go to state 40
    s                              shift and go to state 12

state 31

    (8) p -> COLON . type SEMICOLON q
    (70) type -> . INT
    (71) type -> . FLOAT

    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    type                           shift and go to state 41

state 32

    (11) body -> LEFTBRACE m RIGHTBRACE .

    END             reduce using rule 11 (body -> LEFTBRACE m RIGHTBRACE .)
    WHILE           reduce using rule 11 (body -> LEFTBRACE m RIGHTBRACE .)
    ELSEIF          reduce using rule 11 (body -> LEFTBRACE m RIGHTBRACE .)
    ELSE            reduce using rule 11 (body -> LEFTBRACE m RIGHTBRACE .)
    SEMICOLON       reduce using rule 11 (body -> LEFTBRACE m RIGHTBRACE .)


state 33

    (12) m -> statement m .

    RIGHTBRACE      reduce using rule 12 (m -> statement m .)


state 34

    (18) assign -> id_assign equal_assign . expression SEMICOLON
    (36) expression -> . exp j
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    expression                     shift and go to state 44
    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 35

    (20) equal_assign -> EQUAL .

    LEFTPARENTHESIS reduce using rule 20 (equal_assign -> EQUAL .)
    ADD             reduce using rule 20 (equal_assign -> EQUAL .)
    MINUS           reduce using rule 20 (equal_assign -> EQUAL .)
    ID              reduce using rule 20 (equal_assign -> EQUAL .)
    CTE_INT         reduce using rule 20 (equal_assign -> EQUAL .)
    CTE_FLOAT       reduce using rule 20 (equal_assign -> EQUAL .)


state 36

    (25) condition -> IF left_par_condition . expression right_par_condition body ef SEMICOLON
    (36) expression -> . exp j
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    expression                     shift and go to state 54
    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 37

    (26) left_par_condition -> LEFTPARENTHESIS .

    LEFTPARENTHESIS reduce using rule 26 (left_par_condition -> LEFTPARENTHESIS .)
    ADD             reduce using rule 26 (left_par_condition -> LEFTPARENTHESIS .)
    MINUS           reduce using rule 26 (left_par_condition -> LEFTPARENTHESIS .)
    ID              reduce using rule 26 (left_par_condition -> LEFTPARENTHESIS .)
    CTE_INT         reduce using rule 26 (left_par_condition -> LEFTPARENTHESIS .)
    CTE_FLOAT       reduce using rule 26 (left_par_condition -> LEFTPARENTHESIS .)


state 38

    (21) cycle -> do_cycle body . WHILE l_par_cycle expression r_par_cycle SEMICOLON

    WHILE           shift and go to state 55


state 39

    (42) print -> cout_print LEFTPARENTHESIS . g RIGHTPARENTHESIS semicolon_print
    (44) g -> . h i
    (45) h -> . expression_print
    (46) h -> . CTE_STRING
    (47) expression_print -> . expression
    (36) expression -> . exp j
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    CTE_STRING      shift and go to state 59
    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    g                              shift and go to state 56
    h                              shift and go to state 57
    expression_print               shift and go to state 58
    expression                     shift and go to state 60
    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 40

    (7) p -> COMA o .

    LEFTBRACE       reduce using rule 7 (p -> COMA o .)


state 41

    (8) p -> COLON type . SEMICOLON q

    SEMICOLON       shift and go to state 61


state 42

    (70) type -> INT .

    SEMICOLON       reduce using rule 70 (type -> INT .)


state 43

    (71) type -> FLOAT .

    SEMICOLON       reduce using rule 71 (type -> FLOAT .)


state 44

    (18) assign -> id_assign equal_assign expression . SEMICOLON

    SEMICOLON       shift and go to state 62


state 45

    (36) expression -> exp . j
    (37) j -> . empty
    (38) j -> . k exp
    (74) empty -> .
    (39) k -> . GREATERTHAN
    (40) k -> . LESSTHAN
    (41) k -> . NOT

    SEMICOLON       reduce using rule 74 (empty -> .)
    RIGHTPARENTHESIS reduce using rule 74 (empty -> .)
    COMA            reduce using rule 74 (empty -> .)
    GREATERTHAN     shift and go to state 66
    LESSTHAN        shift and go to state 67
    NOT             shift and go to state 68

    j                              shift and go to state 63
    empty                          shift and go to state 64
    k                              shift and go to state 65

state 46

    (51) exp -> term . e
    (52) e -> . empty
    (53) e -> . f exp
    (74) empty -> .
    (54) f -> . ADD
    (55) f -> . MINUS

    GREATERTHAN     reduce using rule 74 (empty -> .)
    LESSTHAN        reduce using rule 74 (empty -> .)
    NOT             reduce using rule 74 (empty -> .)
    SEMICOLON       reduce using rule 74 (empty -> .)
    RIGHTPARENTHESIS reduce using rule 74 (empty -> .)
    COMA            reduce using rule 74 (empty -> .)
    ADD             shift and go to state 72
    MINUS           shift and go to state 73

    e                              shift and go to state 69
    empty                          shift and go to state 70
    f                              shift and go to state 71

state 47

    (56) term -> factor . c
    (57) c -> . empty
    (58) c -> . d term
    (74) empty -> .
    (59) d -> . MULTIPLY
    (60) d -> . DIVIDE

    ADD             reduce using rule 74 (empty -> .)
    MINUS           reduce using rule 74 (empty -> .)
    GREATERTHAN     reduce using rule 74 (empty -> .)
    LESSTHAN        reduce using rule 74 (empty -> .)
    NOT             reduce using rule 74 (empty -> .)
    SEMICOLON       reduce using rule 74 (empty -> .)
    RIGHTPARENTHESIS reduce using rule 74 (empty -> .)
    COMA            reduce using rule 74 (empty -> .)
    MULTIPLY        shift and go to state 77
    DIVIDE          shift and go to state 78

    c                              shift and go to state 74
    empty                          shift and go to state 75
    d                              shift and go to state 76

state 48

    (61) factor -> left_par_factor . expression right_par_factor
    (36) expression -> . exp j
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    left_par_factor                shift and go to state 48
    expression                     shift and go to state 79
    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 49

    (62) factor -> a . b
    (68) b -> . ID
    (69) b -> . cte
    (72) cte -> . CTE_INT
    (73) cte -> . CTE_FLOAT

    ID              shift and go to state 81
    CTE_INT         shift and go to state 83
    CTE_FLOAT       shift and go to state 84

    b                              shift and go to state 80
    cte                            shift and go to state 82

state 50

    (63) left_par_factor -> LEFTPARENTHESIS .

    LEFTPARENTHESIS reduce using rule 63 (left_par_factor -> LEFTPARENTHESIS .)
    ADD             reduce using rule 63 (left_par_factor -> LEFTPARENTHESIS .)
    MINUS           reduce using rule 63 (left_par_factor -> LEFTPARENTHESIS .)
    ID              reduce using rule 63 (left_par_factor -> LEFTPARENTHESIS .)
    CTE_INT         reduce using rule 63 (left_par_factor -> LEFTPARENTHESIS .)
    CTE_FLOAT       reduce using rule 63 (left_par_factor -> LEFTPARENTHESIS .)


state 51

    (65) a -> empty .

    ID              reduce using rule 65 (a -> empty .)
    CTE_INT         reduce using rule 65 (a -> empty .)
    CTE_FLOAT       reduce using rule 65 (a -> empty .)


state 52

    (66) a -> ADD .

    ID              reduce using rule 66 (a -> ADD .)
    CTE_INT         reduce using rule 66 (a -> ADD .)
    CTE_FLOAT       reduce using rule 66 (a -> ADD .)


state 53

    (67) a -> MINUS .

    ID              reduce using rule 67 (a -> MINUS .)
    CTE_INT         reduce using rule 67 (a -> MINUS .)
    CTE_FLOAT       reduce using rule 67 (a -> MINUS .)


state 54

    (25) condition -> IF left_par_condition expression . right_par_condition body ef SEMICOLON
    (27) right_par_condition -> . RIGHTPARENTHESIS

    RIGHTPARENTHESIS shift and go to state 86

    right_par_condition            shift and go to state 85

state 55

    (21) cycle -> do_cycle body WHILE . l_par_cycle expression r_par_cycle SEMICOLON
    (23) l_par_cycle -> . LEFTPARENTHESIS

    LEFTPARENTHESIS shift and go to state 88

    l_par_cycle                    shift and go to state 87

state 56

    (42) print -> cout_print LEFTPARENTHESIS g . RIGHTPARENTHESIS semicolon_print

    RIGHTPARENTHESIS shift and go to state 89


state 57

    (44) g -> h . i
    (48) i -> . empty
    (49) i -> . COMA g
    (74) empty -> .

    COMA            shift and go to state 92
    RIGHTPARENTHESIS reduce using rule 74 (empty -> .)

    i                              shift and go to state 90
    empty                          shift and go to state 91

state 58

    (45) h -> expression_print .

    COMA            reduce using rule 45 (h -> expression_print .)
    RIGHTPARENTHESIS reduce using rule 45 (h -> expression_print .)


state 59

    (46) h -> CTE_STRING .

    COMA            reduce using rule 46 (h -> CTE_STRING .)
    RIGHTPARENTHESIS reduce using rule 46 (h -> CTE_STRING .)


state 60

    (47) expression_print -> expression .

    COMA            reduce using rule 47 (expression_print -> expression .)
    RIGHTPARENTHESIS reduce using rule 47 (expression_print -> expression .)


state 61

    (8) p -> COLON type SEMICOLON . q
    (9) q -> . empty
    (10) q -> . o
    (74) empty -> .
    (5) o -> . s p
    (6) s -> . ID

    LEFTBRACE       reduce using rule 74 (empty -> .)
    ID              shift and go to state 13

    q                              shift and go to state 93
    empty                          shift and go to state 94
    o                              shift and go to state 95
    s                              shift and go to state 12

state 62

    (18) assign -> id_assign equal_assign expression SEMICOLON .

    IF              reduce using rule 18 (assign -> id_assign equal_assign expression SEMICOLON .)
    ID              reduce using rule 18 (assign -> id_assign equal_assign expression SEMICOLON .)
    DO              reduce using rule 18 (assign -> id_assign equal_assign expression SEMICOLON .)
    COUT            reduce using rule 18 (assign -> id_assign equal_assign expression SEMICOLON .)
    RIGHTBRACE      reduce using rule 18 (assign -> id_assign equal_assign expression SEMICOLON .)


state 63

    (36) expression -> exp j .

    SEMICOLON       reduce using rule 36 (expression -> exp j .)
    RIGHTPARENTHESIS reduce using rule 36 (expression -> exp j .)
    COMA            reduce using rule 36 (expression -> exp j .)


state 64

    (37) j -> empty .

    SEMICOLON       reduce using rule 37 (j -> empty .)
    RIGHTPARENTHESIS reduce using rule 37 (j -> empty .)
    COMA            reduce using rule 37 (j -> empty .)


state 65

    (38) j -> k . exp
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    exp                            shift and go to state 96
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 66

    (39) k -> GREATERTHAN .

    LEFTPARENTHESIS reduce using rule 39 (k -> GREATERTHAN .)
    ADD             reduce using rule 39 (k -> GREATERTHAN .)
    MINUS           reduce using rule 39 (k -> GREATERTHAN .)
    ID              reduce using rule 39 (k -> GREATERTHAN .)
    CTE_INT         reduce using rule 39 (k -> GREATERTHAN .)
    CTE_FLOAT       reduce using rule 39 (k -> GREATERTHAN .)


state 67

    (40) k -> LESSTHAN .

    LEFTPARENTHESIS reduce using rule 40 (k -> LESSTHAN .)
    ADD             reduce using rule 40 (k -> LESSTHAN .)
    MINUS           reduce using rule 40 (k -> LESSTHAN .)
    ID              reduce using rule 40 (k -> LESSTHAN .)
    CTE_INT         reduce using rule 40 (k -> LESSTHAN .)
    CTE_FLOAT       reduce using rule 40 (k -> LESSTHAN .)


state 68

    (41) k -> NOT .

    LEFTPARENTHESIS reduce using rule 41 (k -> NOT .)
    ADD             reduce using rule 41 (k -> NOT .)
    MINUS           reduce using rule 41 (k -> NOT .)
    ID              reduce using rule 41 (k -> NOT .)
    CTE_INT         reduce using rule 41 (k -> NOT .)
    CTE_FLOAT       reduce using rule 41 (k -> NOT .)


state 69

    (51) exp -> term e .

    GREATERTHAN     reduce using rule 51 (exp -> term e .)
    LESSTHAN        reduce using rule 51 (exp -> term e .)
    NOT             reduce using rule 51 (exp -> term e .)
    SEMICOLON       reduce using rule 51 (exp -> term e .)
    RIGHTPARENTHESIS reduce using rule 51 (exp -> term e .)
    COMA            reduce using rule 51 (exp -> term e .)


state 70

    (52) e -> empty .

    GREATERTHAN     reduce using rule 52 (e -> empty .)
    LESSTHAN        reduce using rule 52 (e -> empty .)
    NOT             reduce using rule 52 (e -> empty .)
    SEMICOLON       reduce using rule 52 (e -> empty .)
    RIGHTPARENTHESIS reduce using rule 52 (e -> empty .)
    COMA            reduce using rule 52 (e -> empty .)


state 71

    (53) e -> f . exp
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    exp                            shift and go to state 97
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 72

    (54) f -> ADD .

    LEFTPARENTHESIS reduce using rule 54 (f -> ADD .)
    ADD             reduce using rule 54 (f -> ADD .)
    MINUS           reduce using rule 54 (f -> ADD .)
    ID              reduce using rule 54 (f -> ADD .)
    CTE_INT         reduce using rule 54 (f -> ADD .)
    CTE_FLOAT       reduce using rule 54 (f -> ADD .)


state 73

    (55) f -> MINUS .

    LEFTPARENTHESIS reduce using rule 55 (f -> MINUS .)
    ADD             reduce using rule 55 (f -> MINUS .)
    MINUS           reduce using rule 55 (f -> MINUS .)
    ID              reduce using rule 55 (f -> MINUS .)
    CTE_INT         reduce using rule 55 (f -> MINUS .)
    CTE_FLOAT       reduce using rule 55 (f -> MINUS .)


state 74

    (56) term -> factor c .

    ADD             reduce using rule 56 (term -> factor c .)
    MINUS           reduce using rule 56 (term -> factor c .)
    GREATERTHAN     reduce using rule 56 (term -> factor c .)
    LESSTHAN        reduce using rule 56 (term -> factor c .)
    NOT             reduce using rule 56 (term -> factor c .)
    SEMICOLON       reduce using rule 56 (term -> factor c .)
    RIGHTPARENTHESIS reduce using rule 56 (term -> factor c .)
    COMA            reduce using rule 56 (term -> factor c .)


state 75

    (57) c -> empty .

    ADD             reduce using rule 57 (c -> empty .)
    MINUS           reduce using rule 57 (c -> empty .)
    GREATERTHAN     reduce using rule 57 (c -> empty .)
    LESSTHAN        reduce using rule 57 (c -> empty .)
    NOT             reduce using rule 57 (c -> empty .)
    SEMICOLON       reduce using rule 57 (c -> empty .)
    RIGHTPARENTHESIS reduce using rule 57 (c -> empty .)
    COMA            reduce using rule 57 (c -> empty .)


state 76

    (58) c -> d . term
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    term                           shift and go to state 98
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 77

    (59) d -> MULTIPLY .

    LEFTPARENTHESIS reduce using rule 59 (d -> MULTIPLY .)
    ADD             reduce using rule 59 (d -> MULTIPLY .)
    MINUS           reduce using rule 59 (d -> MULTIPLY .)
    ID              reduce using rule 59 (d -> MULTIPLY .)
    CTE_INT         reduce using rule 59 (d -> MULTIPLY .)
    CTE_FLOAT       reduce using rule 59 (d -> MULTIPLY .)


state 78

    (60) d -> DIVIDE .

    LEFTPARENTHESIS reduce using rule 60 (d -> DIVIDE .)
    ADD             reduce using rule 60 (d -> DIVIDE .)
    MINUS           reduce using rule 60 (d -> DIVIDE .)
    ID              reduce using rule 60 (d -> DIVIDE .)
    CTE_INT         reduce using rule 60 (d -> DIVIDE .)
    CTE_FLOAT       reduce using rule 60 (d -> DIVIDE .)


state 79

    (61) factor -> left_par_factor expression . right_par_factor
    (64) right_par_factor -> . RIGHTPARENTHESIS

    RIGHTPARENTHESIS shift and go to state 100

    right_par_factor               shift and go to state 99

state 80

    (62) factor -> a b .

    MULTIPLY        reduce using rule 62 (factor -> a b .)
    DIVIDE          reduce using rule 62 (factor -> a b .)
    ADD             reduce using rule 62 (factor -> a b .)
    MINUS           reduce using rule 62 (factor -> a b .)
    GREATERTHAN     reduce using rule 62 (factor -> a b .)
    LESSTHAN        reduce using rule 62 (factor -> a b .)
    NOT             reduce using rule 62 (factor -> a b .)
    SEMICOLON       reduce using rule 62 (factor -> a b .)
    RIGHTPARENTHESIS reduce using rule 62 (factor -> a b .)
    COMA            reduce using rule 62 (factor -> a b .)


state 81

    (68) b -> ID .

    MULTIPLY        reduce using rule 68 (b -> ID .)
    DIVIDE          reduce using rule 68 (b -> ID .)
    ADD             reduce using rule 68 (b -> ID .)
    MINUS           reduce using rule 68 (b -> ID .)
    GREATERTHAN     reduce using rule 68 (b -> ID .)
    LESSTHAN        reduce using rule 68 (b -> ID .)
    NOT             reduce using rule 68 (b -> ID .)
    SEMICOLON       reduce using rule 68 (b -> ID .)
    RIGHTPARENTHESIS reduce using rule 68 (b -> ID .)
    COMA            reduce using rule 68 (b -> ID .)


state 82

    (69) b -> cte .

    MULTIPLY        reduce using rule 69 (b -> cte .)
    DIVIDE          reduce using rule 69 (b -> cte .)
    ADD             reduce using rule 69 (b -> cte .)
    MINUS           reduce using rule 69 (b -> cte .)
    GREATERTHAN     reduce using rule 69 (b -> cte .)
    LESSTHAN        reduce using rule 69 (b -> cte .)
    NOT             reduce using rule 69 (b -> cte .)
    SEMICOLON       reduce using rule 69 (b -> cte .)
    RIGHTPARENTHESIS reduce using rule 69 (b -> cte .)
    COMA            reduce using rule 69 (b -> cte .)


state 83

    (72) cte -> CTE_INT .

    MULTIPLY        reduce using rule 72 (cte -> CTE_INT .)
    DIVIDE          reduce using rule 72 (cte -> CTE_INT .)
    ADD             reduce using rule 72 (cte -> CTE_INT .)
    MINUS           reduce using rule 72 (cte -> CTE_INT .)
    GREATERTHAN     reduce using rule 72 (cte -> CTE_INT .)
    LESSTHAN        reduce using rule 72 (cte -> CTE_INT .)
    NOT             reduce using rule 72 (cte -> CTE_INT .)
    SEMICOLON       reduce using rule 72 (cte -> CTE_INT .)
    RIGHTPARENTHESIS reduce using rule 72 (cte -> CTE_INT .)
    COMA            reduce using rule 72 (cte -> CTE_INT .)


state 84

    (73) cte -> CTE_FLOAT .

    MULTIPLY        reduce using rule 73 (cte -> CTE_FLOAT .)
    DIVIDE          reduce using rule 73 (cte -> CTE_FLOAT .)
    ADD             reduce using rule 73 (cte -> CTE_FLOAT .)
    MINUS           reduce using rule 73 (cte -> CTE_FLOAT .)
    GREATERTHAN     reduce using rule 73 (cte -> CTE_FLOAT .)
    LESSTHAN        reduce using rule 73 (cte -> CTE_FLOAT .)
    NOT             reduce using rule 73 (cte -> CTE_FLOAT .)
    SEMICOLON       reduce using rule 73 (cte -> CTE_FLOAT .)
    RIGHTPARENTHESIS reduce using rule 73 (cte -> CTE_FLOAT .)
    COMA            reduce using rule 73 (cte -> CTE_FLOAT .)


state 85

    (25) condition -> IF left_par_condition expression right_par_condition . body ef SEMICOLON
    (11) body -> . LEFTBRACE m RIGHTBRACE

    LEFTBRACE       shift and go to state 10

    body                           shift and go to state 101

state 86

    (27) right_par_condition -> RIGHTPARENTHESIS .

    LEFTBRACE       reduce using rule 27 (right_par_condition -> RIGHTPARENTHESIS .)


state 87

    (21) cycle -> do_cycle body WHILE l_par_cycle . expression r_par_cycle SEMICOLON
    (36) expression -> . exp j
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    expression                     shift and go to state 102
    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 88

    (23) l_par_cycle -> LEFTPARENTHESIS .

    LEFTPARENTHESIS reduce using rule 23 (l_par_cycle -> LEFTPARENTHESIS .)
    ADD             reduce using rule 23 (l_par_cycle -> LEFTPARENTHESIS .)
    MINUS           reduce using rule 23 (l_par_cycle -> LEFTPARENTHESIS .)
    ID              reduce using rule 23 (l_par_cycle -> LEFTPARENTHESIS .)
    CTE_INT         reduce using rule 23 (l_par_cycle -> LEFTPARENTHESIS .)
    CTE_FLOAT       reduce using rule 23 (l_par_cycle -> LEFTPARENTHESIS .)


state 89

    (42) print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS . semicolon_print
    (50) semicolon_print -> . SEMICOLON

    SEMICOLON       shift and go to state 104

    semicolon_print                shift and go to state 103

state 90

    (44) g -> h i .

    RIGHTPARENTHESIS reduce using rule 44 (g -> h i .)


state 91

    (48) i -> empty .

    RIGHTPARENTHESIS reduce using rule 48 (i -> empty .)


state 92

    (49) i -> COMA . g
    (44) g -> . h i
    (45) h -> . expression_print
    (46) h -> . CTE_STRING
    (47) expression_print -> . expression
    (36) expression -> . exp j
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    CTE_STRING      shift and go to state 59
    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    g                              shift and go to state 105
    h                              shift and go to state 57
    expression_print               shift and go to state 58
    expression                     shift and go to state 60
    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 93

    (8) p -> COLON type SEMICOLON q .

    LEFTBRACE       reduce using rule 8 (p -> COLON type SEMICOLON q .)


state 94

    (9) q -> empty .

    LEFTBRACE       reduce using rule 9 (q -> empty .)


state 95

    (10) q -> o .

    LEFTBRACE       reduce using rule 10 (q -> o .)


state 96

    (38) j -> k exp .

    SEMICOLON       reduce using rule 38 (j -> k exp .)
    RIGHTPARENTHESIS reduce using rule 38 (j -> k exp .)
    COMA            reduce using rule 38 (j -> k exp .)


state 97

    (53) e -> f exp .

    GREATERTHAN     reduce using rule 53 (e -> f exp .)
    LESSTHAN        reduce using rule 53 (e -> f exp .)
    NOT             reduce using rule 53 (e -> f exp .)
    SEMICOLON       reduce using rule 53 (e -> f exp .)
    RIGHTPARENTHESIS reduce using rule 53 (e -> f exp .)
    COMA            reduce using rule 53 (e -> f exp .)


state 98

    (58) c -> d term .

    ADD             reduce using rule 58 (c -> d term .)
    MINUS           reduce using rule 58 (c -> d term .)
    GREATERTHAN     reduce using rule 58 (c -> d term .)
    LESSTHAN        reduce using rule 58 (c -> d term .)
    NOT             reduce using rule 58 (c -> d term .)
    SEMICOLON       reduce using rule 58 (c -> d term .)
    RIGHTPARENTHESIS reduce using rule 58 (c -> d term .)
    COMA            reduce using rule 58 (c -> d term .)


state 99

    (61) factor -> left_par_factor expression right_par_factor .

    MULTIPLY        reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    DIVIDE          reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    ADD             reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    MINUS           reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    GREATERTHAN     reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    LESSTHAN        reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    NOT             reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    SEMICOLON       reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    RIGHTPARENTHESIS reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)
    COMA            reduce using rule 61 (factor -> left_par_factor expression right_par_factor .)


state 100

    (64) right_par_factor -> RIGHTPARENTHESIS .

    MULTIPLY        reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    DIVIDE          reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    ADD             reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    MINUS           reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    GREATERTHAN     reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    LESSTHAN        reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    NOT             reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    SEMICOLON       reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    RIGHTPARENTHESIS reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)
    COMA            reduce using rule 64 (right_par_factor -> RIGHTPARENTHESIS .)


state 101

    (25) condition -> IF left_par_condition expression right_par_condition body . ef SEMICOLON
    (28) ef -> . empty
    (29) ef -> . l
    (30) ef -> . elif_ef left_par_ef expression right_par_ef body l
    (74) empty -> .
    (34) l -> . else_condition body
    (31) elif_ef -> . ELSEIF
    (35) else_condition -> . ELSE

    SEMICOLON       reduce using rule 74 (empty -> .)
    ELSEIF          shift and go to state 111
    ELSE            shift and go to state 112

    ef                             shift and go to state 106
    empty                          shift and go to state 107
    l                              shift and go to state 108
    elif_ef                        shift and go to state 109
    else_condition                 shift and go to state 110

state 102

    (21) cycle -> do_cycle body WHILE l_par_cycle expression . r_par_cycle SEMICOLON
    (24) r_par_cycle -> . RIGHTPARENTHESIS

    RIGHTPARENTHESIS shift and go to state 114

    r_par_cycle                    shift and go to state 113

state 103

    (42) print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print .

    IF              reduce using rule 42 (print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print .)
    ID              reduce using rule 42 (print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print .)
    DO              reduce using rule 42 (print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print .)
    COUT            reduce using rule 42 (print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print .)
    RIGHTBRACE      reduce using rule 42 (print -> cout_print LEFTPARENTHESIS g RIGHTPARENTHESIS semicolon_print .)


state 104

    (50) semicolon_print -> SEMICOLON .

    IF              reduce using rule 50 (semicolon_print -> SEMICOLON .)
    ID              reduce using rule 50 (semicolon_print -> SEMICOLON .)
    DO              reduce using rule 50 (semicolon_print -> SEMICOLON .)
    COUT            reduce using rule 50 (semicolon_print -> SEMICOLON .)
    RIGHTBRACE      reduce using rule 50 (semicolon_print -> SEMICOLON .)


state 105

    (49) i -> COMA g .

    RIGHTPARENTHESIS reduce using rule 49 (i -> COMA g .)


state 106

    (25) condition -> IF left_par_condition expression right_par_condition body ef . SEMICOLON

    SEMICOLON       shift and go to state 115


state 107

    (28) ef -> empty .

    SEMICOLON       reduce using rule 28 (ef -> empty .)


state 108

    (29) ef -> l .

    SEMICOLON       reduce using rule 29 (ef -> l .)


state 109

    (30) ef -> elif_ef . left_par_ef expression right_par_ef body l
    (32) left_par_ef -> . LEFTPARENTHESIS

    LEFTPARENTHESIS shift and go to state 117

    left_par_ef                    shift and go to state 116

state 110

    (34) l -> else_condition . body
    (11) body -> . LEFTBRACE m RIGHTBRACE

    LEFTBRACE       shift and go to state 10

    body                           shift and go to state 118

state 111

    (31) elif_ef -> ELSEIF .

    LEFTPARENTHESIS reduce using rule 31 (elif_ef -> ELSEIF .)


state 112

    (35) else_condition -> ELSE .

    LEFTBRACE       reduce using rule 35 (else_condition -> ELSE .)


state 113

    (21) cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle . SEMICOLON

    SEMICOLON       shift and go to state 119


state 114

    (24) r_par_cycle -> RIGHTPARENTHESIS .

    SEMICOLON       reduce using rule 24 (r_par_cycle -> RIGHTPARENTHESIS .)


state 115

    (25) condition -> IF left_par_condition expression right_par_condition body ef SEMICOLON .

    IF              reduce using rule 25 (condition -> IF left_par_condition expression right_par_condition body ef SEMICOLON .)
    ID              reduce using rule 25 (condition -> IF left_par_condition expression right_par_condition body ef SEMICOLON .)
    DO              reduce using rule 25 (condition -> IF left_par_condition expression right_par_condition body ef SEMICOLON .)
    COUT            reduce using rule 25 (condition -> IF left_par_condition expression right_par_condition body ef SEMICOLON .)
    RIGHTBRACE      reduce using rule 25 (condition -> IF left_par_condition expression right_par_condition body ef SEMICOLON .)


state 116

    (30) ef -> elif_ef left_par_ef . expression right_par_ef body l
    (36) expression -> . exp j
    (51) exp -> . term e
    (56) term -> . factor c
    (61) factor -> . left_par_factor expression right_par_factor
    (62) factor -> . a b
    (63) left_par_factor -> . LEFTPARENTHESIS
    (65) a -> . empty
    (66) a -> . ADD
    (67) a -> . MINUS
    (74) empty -> .

    LEFTPARENTHESIS shift and go to state 50
    ADD             shift and go to state 52
    MINUS           shift and go to state 53
    ID              reduce using rule 74 (empty -> .)
    CTE_INT         reduce using rule 74 (empty -> .)
    CTE_FLOAT       reduce using rule 74 (empty -> .)

    expression                     shift and go to state 120
    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    left_par_factor                shift and go to state 48
    a                              shift and go to state 49
    empty                          shift and go to state 51

state 117

    (32) left_par_ef -> LEFTPARENTHESIS .

    LEFTPARENTHESIS reduce using rule 32 (left_par_ef -> LEFTPARENTHESIS .)
    ADD             reduce using rule 32 (left_par_ef -> LEFTPARENTHESIS .)
    MINUS           reduce using rule 32 (left_par_ef -> LEFTPARENTHESIS .)
    ID              reduce using rule 32 (left_par_ef -> LEFTPARENTHESIS .)
    CTE_INT         reduce using rule 32 (left_par_ef -> LEFTPARENTHESIS .)
    CTE_FLOAT       reduce using rule 32 (left_par_ef -> LEFTPARENTHESIS .)


state 118

    (34) l -> else_condition body .

    SEMICOLON       reduce using rule 34 (l -> else_condition body .)


state 119

    (21) cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON .

    IF              reduce using rule 21 (cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON .)
    ID              reduce using rule 21 (cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON .)
    DO              reduce using rule 21 (cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON .)
    COUT            reduce using rule 21 (cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON .)
    RIGHTBRACE      reduce using rule 21 (cycle -> do_cycle body WHILE l_par_cycle expression r_par_cycle SEMICOLON .)


state 120

    (30) ef -> elif_ef left_par_ef expression . right_par_ef body l
    (33) right_par_ef -> . RIGHTPARENTHESIS

    RIGHTPARENTHESIS shift and go to state 122

    right_par_ef                   shift and go to state 121

state 121

    (30) ef -> elif_ef left_par_ef expression right_par_ef . body l
    (11) body -> . LEFTBRACE m RIGHTBRACE

    LEFTBRACE       shift and go to state 10

    body                           shift and go to state 123

state 122

    (33) right_par_ef -> RIGHTPARENTHESIS .

    LEFTBRACE       reduce using rule 33 (right_par_ef -> RIGHTPARENTHESIS .)


state 123

    (30) ef -> elif_ef left_par_ef expression right_par_ef body . l
    (34) l -> . else_condition body
    (35) else_condition -> . ELSE

    ELSE            shift and go to state 112

    l                              shift and go to state 124
    else_condition                 shift and go to state 110

state 124

    (30) ef -> elif_ef left_par_ef expression right_par_ef body l .

    SEMICOLON       reduce using rule 30 (ef -> elif_ef left_par_ef expression right_par_ef body l .)

